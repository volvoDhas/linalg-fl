//core matrix arithmetic library
//implements matrix as a list of lists

//--------- type definitions------------------

//The {*a}range type defines an interval 
//between a lower bound and an upper bound
lettype *a range = RANGE *a *a;

//Constructor for the range type
let mk_range l h = 
    l > h => error "low-lim > high-lim" |
    (RANGE l h)
;

//utilities for the range type
//converts an integer range to a float range
let intr2floatr {r::{int} range} =
    val(RANGE li hi) = r in
    mk_range (int2float li) (int2float hi)
;

//converts an integer range to a bv range
let intr2bvr {r::{int} range} =
    val (RANGE li hi) = r in
    mk_range (int2bv li) (int2bv hi)
;

//Pretty printers for int, float and bv ranges
let Prangei (RANGE {l::int} {h::int}) = (printf "(%d,%d)" l h) seq "";
let Prangeb (RANGE {l::bv} {h::bv}) = 
    let bv2str b =
	let bl = bv2list b in  
	list2str T "<" "," ">" (\b. bool2str 5 b) bl
    in
    (printf "(%s,%s)" (bv2str l) (bv2str h)) seq "";
let Prangef (RANGE {l::float} {h::float}) =
    (printf "(%s,%s)" (float2str l) (float2str h)) seq "";

install_print_function Prangei;
install_print_function Prangeb;
install_print_function Prangef;


//--------- special ops-----------------------

//applies the operator f for each element of a list with a scalar
let zipwithsc xs n f = map (\x. f x n) xs;

//applies the operator f element-wise to 2 lists
let zipwith xs ys f = map2 f xs ys;

//returns list-wise zipwith between a (list) list and a scalar
let lmap f m v = map (\r. f r v) m;

//returns the element-wise map of f over a (list) list m
let mmap f m = map (\r. map f r) m;

//returns true if list is empty, false otherwise
let islempty l = length l == 0 => T | F;
let ismempty m = length (flat m) == 0 => T | F;

//overloading seems to fail because of a type inf bug in fl
//overload isempty islempty ismempty;

//returns an list/matrix of zeros
let lzeros n = replicate n '0;
let mzeros m n = replicate m (lzeros n);
overload zeros lzeros mzeros;

//--------- add ops-----------------------

//NOTE - the following sequence of 
//overloading definitions for add
//declares 3 base types explicitly (int, bv, float)
//overload resolution problems occur
//when the ' operator is used

open_overload {opadd :: *a -> *b -> *a};

//int-int version
let iadd {i::int} {j::int} = i+j; 
add_open_overload opadd iadd;

//float-float version
let fadd {i::float} {j::float} = i+j;
add_open_overload opadd fadd;

//bv-bv version
let badd {i::bv} {j::bv} = i+j;  // bv version
add_open_overload opadd badd;

//int range - int range version
let riadd {i:: {int} range} {j:: {int} range} =
    val (RANGE il ih) = i in
    val (RANGE jl jh) = j in
    mk_range (iadd il jl) (iadd ih jh)
;
add_open_overload opadd riadd;

//int range - int version
let riaddi {i:: {int} range} {j:: int} =
    val (RANGE il ih) = i in
    mk_range (iadd il j) (iadd ih j)
;
add_open_overload opadd riaddi;

//float range - float range version
let rfadd {i:: {float} range} {j:: {float} range} =
    val (RANGE il ih) = i in
    val (RANGE jl jh) = j in
    mk_range (fadd il jl) (fadd ih jh)
;
add_open_overload opadd rfadd;

//float range - float version
let rfaddf {i:: {float} range} {j:: float} =
    val (RANGE il ih) = i in
    mk_range (fadd il j) (fadd ih j)
;
add_open_overload opadd rfaddf;

//bv range - bv range version
let rbvadd {i:: {bv} range} {j:: {bv} range} =
    val (RANGE il ih) = i in
    val (RANGE jl jh) = j in
    mk_range (badd il jl) (badd ih jh)
;
add_open_overload opadd rbvadd;

//bv range - bv version
let rbvaddbv {i:: {bv} range} {j:: bv} =
    val (RANGE il ih) = i in
    mk_range (badd il j) (badd ih j)
;
add_open_overload opadd rbvaddbv;

//returns sum of elements of a list
open_overload {lsum :: *a list -> *a};

letrec lsumi {us::int list} = 
    length us == 0 => 0 | opadd (hd us) (lsumi (tl us));
add_open_overload lsum lsumi;

letrec lsumf {us::float list} = 
    length us == 0 => 0.0 | opadd (hd us) (lsumf (tl us));
add_open_overload lsum lsumf;

letrec lsumbv {us::bv list} = 
    length us == 0 => (int2bv 0) | opadd (hd us) (lsumbv (tl us));
add_open_overload lsum lsumbv;

letrec lsumri {uis :: ({int} range) list} = 
    length uis == 0 => mk_range 0 0 | 
    opadd (hd uis) (lsumri (tl uis))
;
add_open_overload lsum lsumri;

letrec lsumrf {uis :: ({float} range) list} = 
    length uis == 0 => mk_range 0.0 0.0 | 
    opadd (hd uis) (lsumrf (tl uis))
;
add_open_overload lsum lsumrf;

letrec lsumrbv {uis :: ({bv} range) list} = 
    length uis == 0 => mk_range (int2bv 0) (int2bv 0) | 
    opadd (hd uis) (lsumrbv (tl uis))
;
add_open_overload lsum lsumrbv;

//returns a list of sum of elements of each row
//all numeric types applicable
let msum m = map lsum m;

//NOTE - lsum & msum cannot be overloaded becuse of
//a presumed type inference bug in fl
//overload sum lsum msum;

//returns the element-wise sum 2 lists
let laddl us vs =  zipwith us vs opadd;


//returns the row-wise sum of a matrix and a vector
let maddl m vs = lmap laddl m vs;

//returns the element-wise sum of a list and a scalar
let laddsc us s = zipwithsc us s opadd;

//returns the element-wise sum of a matrix and a scalar
let maddsc m s = map (\r. laddsc r s) m;

//TODO - overloading of all add ops
//paused because of a presumed type inference bug in fl
//overload add laddl maddl laddsc maddsc;

//--------- diff ops-----------------------

//NOTE - the following sequence of 
//overloading definitions for subtract
//declares 3 base types explicitly (int, bv, float)
//overload resolution problems occur
//when the ' operator is used

open_overload {opsub :: *a -> *b -> *a};

//int-int version
let isub {i::int} {j::int} = i-j; 
add_open_overload opsub isub;

//float-float version
let fsub {i::float} {j::float} = i-j; 
add_open_overload opsub fsub;

//bv-bv version
let bvsub {i::bv} {j::bv} = i-j; 
add_open_overload opsub bvsub;


//returns the element-wise difference of 2 lists
let ldiffl us vs = zipwith us vs opsub;

//returns the row-wise difference between a matrix and a vector
let mdiffl m vs = lmap ldiffl m vs;

//returns the element-wise difference between a list and a scalar
let ldiffsc us v = zipwithsc us v opsub;

//returns the element-wise difference between a matrix and a scalar
let mdiffsc m v = mmap (\e. e-v) m;

//TODO - overloading of all diff ops
//paused because of a presumed type inference bug in fl

//--------- mul ops-----------------------

//the defix * operator
let opmul = (defix *);

//returns the dot product of 2 lists
let dot us vs = lsum (zipwith us vs opmul);

//returns the dot product of 2 scaled lists
//output in scaled form
let sdot us vs scale = lsum (map2 (\u. \v. u*v/scale) us vs);


//returns the product of 2 matrices lhs*rhs 
//with rhs in a transposed form
let mmultm m1 tm2 =
    let crossmap row = map (\col. dot row col) tm2 in
    map crossmap m1
;

//returns the product of 2 scaled matrices lhs*rhs 
//with rhs in a transposed form
let smmultm m1 tm2 scale =
    let crossmap row = map (\col. sdot row col scale) tm2 in
    map crossmap m1
;

//returns the product of 2 matrices
//TODO - change to an efficient version
let mmulm m1 m2 =
    let tm2 = transpose m2 in
    mmultm m1 tm2;
;

//returns the product of 2 scaled matrices
//TODO - change to an efficient version
let smmulm m1 m2 scale =
    let tm2 = transpose m2 in
    smmultm m1 tm2 scale;
;


//returns the element-wise product of a list and a scalar
let lmulsc us v = zipwithsc us v opmul;

//returns the element-wise product of a matrix and a scalar
let mmulsc m v = mmap (\e. e*v) m;

//--------- div ops-----------------------

//the defix / operator
let opdiv = (defix /);

//returns the element-wise quotient of a list and a scalar
let divel us v = zipwithsc us v opdiv;

//--------- min-max ops-----------------------

//retruns the highest element of a list
letrec lmax us = 
    length us <= 1 => hd us |
    max (hd us) (lmax (tl us))
;

//retruns the lowest element of a list
letrec lmin us = 
    length us <= 1 => hd us |
    min (hd us) (lmax (tl us))
;

//--------- index ops-----------------------
//NOTE - in fl, indices start from 1

//retruns the first index of an element in the list
letrec fstindexof us u =
    letrec search [] = 1
	/\search us = (hd us) == u => 1 | 1 + (search (tl us))
    in
    let index = search us in
    index > (length us) => 0 | index
;


//returns the index of the max element in the list
letrec largmax us = fstindexof us (lmax us);

//returns a vector of indexes of max element in each row
letrec margmax m = map largmax m;
