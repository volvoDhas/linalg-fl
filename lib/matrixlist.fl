//core matrix arithmetic library
//implements matrix as a list of lists


//--------- special ops-----------------------

//returns true if list is empty, false otherwise
let islempty l = length l == 0 => T | F;
let ismempty m = length (flat m) == 0 => T | F;

//overloading seems to fail because of a type inf bug in fl
//overload isempty islempty ismempty;

//returns an list/matrix of zeros
let lzeros n = replicate n '0;
let mzeros m n = replicate m (lzeros n);
overload zeros lzeros mzeros;

//returns the element-wise map of f over a (list) list m
let mmap f m = map (\r. map f r) m;

//returns sum of elements of a list
//all numeric types applicable
letrec lsum us = length us == 0 => '0 | (hd us) + (lsum (tl us));

//returns a list of sum of elements of each row
//all numeric types applicable
let msum m = map lsum m;

//NOTE - lsum & msum cannot be overloaded becuse of
//a presumed type inference bug in fl
//overload sum lsum msum;

//--------- add ops-----------------------

//returns the element-wise sum 2 lists
let laddl us vs =  map2 (\u.\v. u+v) us vs;

//returns the row-wise sum of a matrix and a vector
let maddl m vs = map (\r. laddl r vs) m;

//returns the element-wise sum of a list and a scalar
let laddsc us s = map (\u. u+s) us;

//returns the element-wise sum of a matrix and a scalar
let maddsc m s = map (\r. laddsc r s) m;

//TODO - overloading of all add ops
//paused because of a presumed type inference bug in fl

//--------- diff ops-----------------------

//returns the element-wise difference of 2 lists
let ldiffl us vs = map2 (\u.\v. u-v) us vs;

//returns the row-wise difference between a matrix and a vector
let mdiffl m vs = map (\r. ldiffl r vs) m;

//returns the element-wise difference between a list and a scalar
let ldiffsc us v = map (\u. u-v) us;

//returns the element-wise difference between a matrix and a scalar
let mdiffsc m v = mmap (\e. e-v) m;

//TODO - overloading of all diff ops
//paused because of a presumed type inference bug in fl

//--------- mul ops-----------------------

//returns the dot product of 2 lists
let dot us vs = lsum (map2 (\u. \v. u*v) us vs);

//returns the product of 2 matrices
//TODO - change to an efficient version
let mmulm m1 m2 =
    let tm2 = transpose m2 in
    letrec colit row j =
	j > (length tm2) => [] |
	(dot row (el j tm2)):(colit row (j+1))
    in
    letrec rowit i =
	i > (length m1) => [] |
	(colit (el i m1) i):(rowit (i+1))
    in
    rowit 1
;

//returns the element-wise product of a list and a scalar
let lmulsc us v = map (\u. u*v) us;

//returns the element-wise product of a matrix and a scalar
let mmulsc m v = mmap (\e. e*v) m;

//--------- div ops-----------------------

//returns the element-wise quotient of a list and a scalar
let divel us v = map (\u. u/v) us;

//--------- min-max ops-----------------------

//retruns the highest element of a list
letrec lmax us = 
    length us <= 1 => hd us |
    max (hd us) (lmax (tl us))
;

//retruns the lowest element of a list
letrec lmin us = 
    length us <= 1 => hd us |
    min (hd us) (lmax (tl us))
;

//--------- index ops-----------------------
//NOTE - in fl, indices start from 1

//retruns the first index of an element in the list
letrec fstindexof us u =
    letrec search [] = 1
	/\search us = (hd us) == u => 1 | 1 + (search (tl us))
    in
    let index = search us in
    index > (length us) => 0 | index
;


//returns the index of the max element in the list
letrec argmax us = fstindexof us (lmax us);
