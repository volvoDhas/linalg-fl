//tests for ../lib/matrixlist.fl

load (DIR^"../lib/matrixlist.fl");
load (DIR^"flunit.fl");

//some handy definitions
let lei	    = {[]::int list};
let mei	    = replicate 4 lei;
let li1	    = [1,1];
let lf1	    = map int2float li1;
let lbv1    = map int2bv li1;
let lip	    = [1,2];
let lfp	    = map int2float lip;
let lbvp    = map int2bv lip;
let lzi	    = {zeros 2 :: int list};
let lzf	    = {zeros 2 :: float list};
let lzbv    = {zeros 2 :: bv list};
let mzi	    = {zeros 4 2 :: (int list) list};
let lip	    = [1,2];
let mip	    = replicate 4 lip;
let mzf	    = {zeros 4 2 :: (float list) list};
let lfp	    = [1.0,2.0];
let mfp	    = replicate 4 lfp;
let mzbv    = {zeros 4 2 :: (bv list) list};
let lbvp    = [int2bv 1, int2bv 2];
let mbvp    = replicate 4 lbvp;
let mi1	    = replicate 4 li1;
let mf1	    = mmap int2float mi1;
let mbv1    = mmap int2bv mi1;
let scale   = '256;
let miid = [[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]];
let mfid = mmap int2float miid;
let mbvid = mmap int2bv miid;


//testcases for mk_range
let test_mk_range =
(printf "test_mk_range\n") seq
    val (RANGE xi yi) =  (mk_range 1 4) in
    val (RANGE xf yf) =  (mk_range 1.0 4.0) in
    val (RANGE xb yb) =  (mk_range (int2bv 1) (int2bv 4)) in
    let ls = variable "l" => (int2bv 1) | (int2bv 2) in
    let hs = variable "h" => (int2bv 2) | (int2bv 3) in
    let ls' = variable "l" => (int2bv 4) | (int2bv 5) in
    val (RANGE xs ys) = mk_range ls hs in
    (check_eq (xi,yi) (1,4)):
    (check_eq (xf,yf) (1.0,4.0)):
    (check_eq (xb,yb) (int2bv 1,int2bv 4)):
    (check_eq (xs,ys) (ls,hs)):
    (check_fail (mk_range ls' hs) (RANGE (int2bv 0) (int2bv 0))):
    []
;

check_res test_mk_range;

//testcases for zipwithsc
let test_zipwithsc = 
(printf "test_zipwithsc\n") seq
    (check_eq (zipwithsc li1 1 (defix +)) (zipwithsc li1 2 (defix *))):
    []
;

check_res test_zipwithsc;

//testcases for zipwith
let test_zipwith = 
(printf "test_zipwith\n") seq
    (check_eq (zipwith li1 li1 (defix +)) (zipwith li1 [2,2] (defix *))):
    []
;

check_res test_zipwith;

//testcases for islempty
(printf "test_islempty\n");
let test_islempty = 
    let l = replicate 4 1 in
    (check_false (islempty l)):
    (check_true (islempty lei)):
    []
;

check_res test_islempty;

//testcases for islempty
(printf "test_ismempty\n");
let test_ismempty = 
    let l = replicate 4 1 in
    let m = replicate 4 l in
    (check_false (ismempty m)):
    (check_true (ismempty mei)):
    []
;

check_res test_ismempty;


//testcases for zeros
(printf "test_zeros\n");
let test_zeros =
    let e1 = {zeros 0 :: int list} in
    let e2 = {zeros (-10) :: int list} in
    let z1 = {zeros 10 :: int list} in
    let me1 = {zeros 0 0 :: (int list) list} in
    let me2 = {zeros 10 (-10) :: (int list) list} in
    let mz1 = {zeros 10 10 :: (int list) list} in
    (check_lempty e1):
    (check_fail e2 []):
    (check_len z1 10):
    (check_mempty me1):
    (check_len mz1 10):
    (check_len (el 1 mz1) 10):
    (check_fail me2 []):
    []
;

check_res test_zeros;

//testcases for mmap
(printf "test_mmap\n");
let test_mmap =
    let m = zeros 2 2 in
    let mm = mmap (\e. e+1) m in
    let fmm = filter (\e. e!=1) (flat mm) in 
    (check_len fmm 0):
    []
;

check_res test_mmap;

//testcases for lsum
(printf "test_lsum\n");
let test_lsum = 
    let li = [1,-1,2,-2,3,-3] in
    let lf = [1.0,-1.0,2.0,-2.0] in
    let lbv =  map int2bv li in
    (check_eq (lsum lei) 0):
    (check_eq (lsum li) 0):
    (check_eq (lsum lf) 0.0):
    (check_eq (lsum lbv) (int2bv 0)):
    []
;

check_res test_lsum;

//testcases for msum
(printf "test_msum\n");
let test_msum = 
    let li = [1,-1,2,-2,3,-3] in
    let mi = replicate 4 li in
    let lf = [1.0,-1.0,2.0,-2.0] in
    let mf = replicate 4 lf in
    let lbv =  map int2bv li in
    let mbv = replicate 4 lbv in
    let lzi = {zeros 4 :: int list} in
    let lzf = {zeros 4 :: float list} in
    let lzbv = map int2bv lzi in
    (check_eq (msum mei) lzi):
    (check_eq (msum mi) lzi):
    (check_eq (msum mf) lzf):
    (check_eq (msum mbv) lzbv):
    []
;

check_res test_msum;


//testcases for laddl
(printf "test_laddl\n");
let test_laddl =
    let lin =	[-1,-2] in
    let lfn =	[-1.0,-2.0] in
    let lbvn =  [int2bv (-1),int2bv (-2)] in
    (check_lempty (laddl lei lei)):
    (check_eq (laddl lip lin) lzi):
    (check_eq (laddl lfp lfn) lzf):
    (check_eq (laddl lbvp lbvn) lzbv):
    (check_fail (laddl lip [-1]) []):
    []
;

check_res test_laddl;


//testcases for maddl
(printf "test_maddl\n");
let test_maddl =
    let lin =	[-1,-2] in
    let lfn =	[-1.0,-2.0] in
    let lbvn =  [int2bv (-1),int2bv (-2)] in
    (check_mempty (maddl mei lei)):
    (check_eq (maddl mip lin) mzi):
    (check_eq (maddl mfp lfn) mzf):
    (check_eq (maddl mbvp lbvn) mzbv):
    []
;

check_res test_maddl;


//testcases for laddsc
(printf "test_laddsc\n");
let test_laddsc = 
    let li1 = [1,1] in
    let lf1 = [1.0,1.0] in
    let lbv1 = map int2bv li1 in
    let lzi = {zeros 2 :: int list} in
    let lzf = {zeros 2 :: float list} in
    let lzbv = {zeros 2 :: bv list} in
    (check_lempty (laddsc lei 1)):
    (check_eq (laddsc li1 (-1)) lzi):
    (check_eq (laddsc lf1 (-1.0)) lzf):
    (check_eq (laddsc lbv1  (int2bv (-1))) lzbv
    ):
    []
;

check_res test_laddsc;

//testcases for maddsc
(printf "test_maddsc\n");
let test_maddsc = 
    let m1i = replicate 2 [1,1] in
    let m1f = replicate 2 [1.0,1.0] in
    let m1bv = mmap int2bv m1i in
    let mzi = {zeros 2 2 :: (int list) list} in
    let mzf = {zeros 2 2 :: (float list) list} in
    let mzbv = {zeros 2 2 :: (bv list) list} in
    (check_mempty (maddsc mei 1)):
    (check_eq (maddsc m1i (-1)) mzi):
    (check_eq (maddsc m1f (-1.0)) mzf):
    (check_eq (maddsc m1bv  (int2bv (-1))) mzbv):
    []
;

check_res test_maddsc;

//testcases for ldiffl
(printf "test_ldiffl\n");
let test_ldiffl = 
    (check_lempty (ldiffl lei lei)):
    (check_eq (ldiffl lip lip) lzi):
    (check_eq (ldiffl lfp lfp) lzf):
    (check_eq (ldiffl lbvp lbvp) lzbv):
    (check_fail (ldiffl lip [-1]) []):
    []
;

check_res test_ldiffl;

//testcases for mdiffl
(printf "test_mdiffl\n");
let test_mdiffl = 
    (check_mempty (mdiffl mei lei)):
    (check_eq (mdiffl mip lip) mzi):
    (check_eq (mdiffl mfp lfp) mzf):
    (check_eq (mdiffl mbvp lbvp) mzbv):
    (check_fail (mdiffl mip [-1]) [[]]):
    []
;

check_res test_mdiffl;


//testcases for ldiffsc
(printf "test_ldiffsc\n");
let test_ldiffsc = 
    (check_lempty (ldiffsc lei 1)):
    (check_eq (ldiffsc li1 1) lzi):
    (check_eq (ldiffsc lf1 1.0) lzf):
    (check_eq (ldiffsc lbv1 (int2bv 1)) lzbv):
    []
;

check_res test_ldiffsc;

//testcases for mdiffsc
(printf "test_mdiffsc\n");
let test_mdiffsc = 
    (check_mempty (mdiffsc mei 1)):
    (check_eq (mdiffsc mi1 1) mzi):
    (check_eq (mdiffsc mf1 1.0) mzf):
    (check_eq (mdiffsc mbv1 (int2bv 1)) mzbv):
    []
;

check_res test_ldiffsc;


//testcases for dot
(print "test_dot\n");
let test_dot =
    let xi = [1,0,0,1] in
    let yi = [4,1,2,2] in
    let yi' = [4,1,2] in
    let xf = map int2float xi in
    let yf = map int2float yi in
    let xb = map int2bv xi in
    let yb = map int2bv yi in 
    (check_eq (dot xi yi) 6):
    (check_eq (dot xf yf) (int2float 6)):
    (check_eq (dot xb yb) (int2bv 6)):
    (check_fail (dot xi yi') (-255)):
    []
;

check_res test_dot;


//testcases for sdot
(print "test_sdot\n");
let test_sdot =
    let xi = (lmulsc [1,0,0,1] scale) in
    let yi = (lmulsc [4,1,2,2] scale) in
    let yi' = (lmulsc [4,1,2] scale) in
    let xf = map int2float xi in
    let yf = map int2float yi in
    let xb = map int2bv xi in
    let yb = map int2bv yi in 
    (check_eq (sdot xi yi scale) (6*scale)):
    (check_eq (sdot xf yf scale) (int2float (6*scale))):
    (check_eq (sdot xb yb scale) (int2bv (6*scale))):
    (check_fail (sdot xi yi' scale) (-255)):
    []
;

check_res test_sdot;

//testcases for mmulm
(print "test_mmulm\n");
let test_mmulm =
    let yi = replicate 4 [4,1,2,2] in
    let yi' = replicate 3 [4,1,2] in
    let yf = mmap int2float yi in
    let yb = mmap int2bv yi in 
    (check_eq (mmulm miid yi) yi):
    (check_eq (mmulm mfid yf) yf):
    (check_eq (mmulm mbvid yb) yb):
    (check_fail (mmulm miid yi') [[]]):
    []
;

check_res test_mmulm;

//testcases for smmulm
(print "test_smmulm\n");
let test_smmulm =
    let yi = replicate 4 [4,1,2,2] in
    let smiid = mmulsc miid scale in
    let syi = mmulsc yi scale in
    let yi' = replicate 3 [4,1,2] in
    let yf = mmap int2float yi in
    let yb = mmap int2bv yi in 
    (check_eq (smmulm smiid syi scale) syi):
    []
;

check_res test_smmulm;

//testcases for mmultm
(print "test_mmultm\n");
let test_mmultm =
    let yi = transpose (replicate 4 [4,1,2,2]) in
    let yi' = transpose (replicate 3 [4,1,2]) in
    let yf = transpose (mmap int2float yi) in
    let yb = transpose (mmap int2bv yi) in 
    (check_eq (mmultm miid yi) (transpose yi)):
    (check_eq (mmultm mfid yf) (transpose yf)):
    (check_eq (mmultm mbvid yb) (transpose yb)):
    (check_fail (mmultm miid yi') [[]]):
    []
;

check_res test_mmultm;

//testcases for smmultm
(print "test_smmultm\n");
let test_smmultm =
    let yi = transpose (replicate 4 [4,1,2,2]) in
    let smiid = mmulsc miid scale in
    let syi = mmulsc yi scale in
    let tsyi = transpose syi in
    (check_eq (smmultm smiid syi scale) tsyi):
    []
;

check_res test_smmultm;

//testcases for lmulsc
(printf "test_lmulsc\n");
let test_lmulsc = 
    (check_lempty (lmulsc lei 1)):
    (check_eq (lmulsc li1 0) lzi):
    (check_eq (lmulsc lf1 0.0) lzf):
    (check_eq (lmulsc lbv1 (int2bv 0)) lzbv):
    []
;

check_res test_lmulsc;

//testcases for divel
(printf "test_divel\n");
let test_divel = 
    (check_lempty (divel lei 1)):
    (check_eq (divel [1,1] 2) [0,0]):
    (check_eq (divel [1.0,1.0] 2.0) [0.5,0.5]):
    (check_eq 
	(divel [int2bv 1, int2bv 1] 
	     (int2bv 2)) 
	[int2bv 0,int2bv 0]
    ):
    (check_fail (divel [1,1] 0) []):
    []
;

check_res test_divel;

//testcases for lmax
(printf "test_lmax\n");
let test_lmax = 
    (check_eq (lmax [1,-1,2,-2,3,-3]) 3):
    (check_eq (lmax [1.0,-1.0,2.0,-2.0]) 2.0):
    (check_eq
	(lmax [(int2bv 1),(int2bv (-1)),
	      (int2bv 2),(int2bv (-2))])
	(int2bv 2)
    ):
    []
;

check_res test_lmax;

//testcases for lmin
(printf "test_lmin\n");
let test_lmin = 
    (check_eq (lmin [1,-1,2,-2,3,-3]) (-3)):
    (check_eq (lmin [1.0,-1.0,2.0,-2.0]) (-2.0)):
    (check_eq
	(lmin [(int2bv 1),(int2bv (-1)),
	      (int2bv 2),(int2bv (-2))])
	(int2bv (-2))
    ):
    []
;

check_res test_lmin;

//testcases for fstindexof
(printf "test_fstindexof\n");
let test_fstindexof = 
    (check_eq (fstindexof [] 4) 0):
    (check_eq (fstindexof [1,-1,2,-2,3,-3] 4) 0):
    (check_eq (fstindexof [1,-1,2,-2,3,-3] 2) 3):
    []
;

check_res test_fstindexof;

//testcases for largmax
(printf "test_largmax\n");
let test_largmax = 
    (check_eq (largmax lei) 0):
    (check_eq (largmax [1,-1,2,-2,3,-3]) 5):
    (check_eq (largmax [1,1,1,1,1,1]) 1):
    []
;

check_res test_largmax;

//testcases for margmax
(printf "test_margmax\n");
let test_margmax = 
    let t1 = replicate 4 [1,-1,2,-2,3,-3] in
    let t2 = replicate 4 [1,1,1,1] in
    (check_eq (margmax mei) lzi):
    (check_eq (margmax t1) (replicate 4 5)):
    (check_eq (margmax t2) (replicate 4 1)):
    []
;

check_res test_largmax;
