//tests for ../lib/matrixlist.fl

load (DIR^"../lib/matrixlist.fl");

//check if evaluation of f returns T
let check_true f =  f == T;

//check if evaluation of f returns F
let check_false f =  f == F;

//check if evaluation is an empty list
let check_lempty f = islempty f;

//check if evaluation is an empty matrix
let check_mempty f = ismempty f;

//check equivalence between output and expected result
let check_eq a b = a == b;

//check if length of returned list is equal to expected value
let check_len l n = check_eq (length l) n;

//check if executing the function fails
//supply fflag as a sanity check
//fflag should be the same type as the correct output
//and choose a value that cannot be expected even if 
//execution does not fail

let check_fail f fflag = 
    let trycatch f =
	f gen_catch (\e. fflag)
    in
   (trycatch f) == fflag
;

//checks and compiles results of a test case
//rs:: a list of T or F depending upon 
//whether a test pased or failed

let check_res rs =
    let ntcs = (length rs) in
    letrec check_test n =
	n > ntcs => 0 |
	(el n rs) => 1 + (check_test (n+1)) |
	(printf "TC -%3d failed\n" n) seq (check_test (n+1))
    in
    let npass = check_test 1 in
    (printf "Result - %d/%d TCs passed\n\n" npass ntcs) seq ()
;

//testcases for islempty
(printf "test_islempty\n");
let test_islempty = 
    let l = replicate 4 1 in
    let e = {[]::int list} in
    (check_false (islempty l)):
    (check_true (islempty e)):
    []
;

check_res test_islempty;

//testcases for islempty
(printf "test_islempty\n");
let test_ismempty = 
    let l = replicate 4 1 in
    let m = replicate 4 l in
    let e = {[]::int list} in
    let me = replicate 4 e in
    (check_false (ismempty m)):
    (check_true (ismempty me)):
    []
;

check_res test_ismempty;


//testcases for zeros
(printf "test_zeros\n");
let test_zeros =
    let e1 = {zeros 0 :: int list} in
    let e2 = {zeros (-10) :: int list} in
    let z1 = {zeros 10 :: int list} in
    let me1 = {zeros 0 0 :: (int list) list} in
    let me2 = {zeros 10 (-10) :: (int list) list} in
    let mz1 = {zeros 10 10 :: (int list) list} in
    (check_lempty e1):
    (check_fail e2 []):
    (check_len z1 10):
    (check_mempty me1):
    (check_len mz1 10):
    (check_len (el 1 mz1) 10):
    (check_fail me2 []):
    []
;

check_res test_zeros;

//testcases for mmap
(printf "test_mmap\n");
let test_mmap =
    let m = zeros 2 2 in
    let mm = mmap (\e. e+1) m in
    let fmm = filter (\e. e!=1) (flat mm) in 
    (check_len fmm 0):
    []
;

check_res test_mmap;

//testcases for lsum
(printf "test_lsum\n");
let test_lsum = 
    (check_eq (lsum []) 0):
    (check_eq (lsum [1,-1,2,-2,3,-3]) 0):
    (check_eq (lsum [1.0,-1.0,2.0,-2.0]) 0.0):
    (check_eq
	(lsum [(int2bv 1),(int2bv (-1)),
	      (int2bv 2),(int2bv (-2))])
	(int2bv 0)
    ):
    []
;

check_res test_lsum;

//testcases for add
(printf "test_add\n");
let test_add = 
    (check_eq (add {[]::int list} {[]::int list}) {[]::int list}):
    (check_eq (add [1,2] [-1,-2]) [0,0]):
    (check_eq (add [1.0,2.0] [-1.0,-2.0]) [0.0,0.0]):
    (check_eq 
	(add [int2bv 1, int2bv 2] 
	     [int2bv (-1),int2bv (-2)]) 
	[int2bv 0, int2bv 0]
    ):
    (check_fail (add [1,2] [-1]) []):
    []
;

check_res test_add;

//testcases for addel
(printf "test_addel\n");
let test_addel = 
    (check_eq (addel {[]::int list} 1) {[]::int list}):
    (check_eq (addel [1,1] (-1)) [0,0]):
    (check_eq (addel [1.0,1.0] (-1.0)) [0.0,0.0]):
    (check_eq 
	(addel [int2bv 1, int2bv 1] 
	     (int2bv (-1))) 
	[int2bv 0,int2bv 0]
    ):
    []
;

check_res test_addel;

//testcases for diff
(printf "test_diff\n");
let test_diff = 
    (check_eq (diff {[]::int list} {[]::int list}) {[]::int list}):
    (check_eq (diff [1,2] [1,2]) [0,0]):
    (check_eq (diff [1.0,2.0] [1.0,2.0]) [0.0,0.0]):
    (check_eq 
	(diff [int2bv 1, int2bv 2] 
	     [int2bv 1,int2bv 2]) 
	[int2bv 0, int2bv 0]
    ):
    (check_fail (diff [1,2] [-1]) []):
    []
;

check_res test_diff;

//testcases for diffel
(printf "test_diffel\n");
let test_diffel = 
    (check_eq (diffel {[]::int list} 1) {[]::int list}):
    (check_eq (diffel [1,1] 1) [0,0]):
    (check_eq (diffel [1.0,1.0] 1.0) [0.0,0.0]):
    (check_eq 
	(diffel [int2bv 1, int2bv 1] 
	     (int2bv 1)) 
	[int2bv 0,int2bv 0]
    ):
    []
;

check_res test_diffel;

//testcases for dot
(print "test_dot\n");
let test_dot =
    let xi = [1,0,0,1] in
    let yi = [4,1,2,2] in
    let yi' = [4,1,2] in
    let xf = map int2float xi in
    let yf = map int2float yi in
    let xb = map int2bv xi in
    let yb = map int2bv yi in 
    (check_eq (dot xi yi) 6):
    (check_eq (dot xf yf) (int2float 6)):
    (check_eq (dot xb yb) (int2bv 6)):
    (check_fail (dot xi yi') (-255)):
    []
;

check_res test_dot;

//testcases for mulel
(printf "test_mulel\n");
let test_mulel = 
    (check_eq (mulel {[]::int list} 1) {[]::int list}):
    (check_eq (mulel [1,1] 0) [0,0]):
    (check_eq (mulel [1.0,1.0] 0.0) [0.0,0.0]):
    (check_eq 
	(mulel [int2bv 1, int2bv 1] 
	     (int2bv 0)) 
	[int2bv 0,int2bv 0]
    ):
    []
;

check_res test_mulel;

//testcases for divel
(printf "test_divel\n");
let test_divel = 
    (check_eq (divel {[]::int list} 1) {[]::int list}):
    (check_eq (divel [1,1] 2) [0,0]):
    (check_eq (divel [1.0,1.0] 2.0) [0.5,0.5]):
    (check_eq 
	(divel [int2bv 1, int2bv 1] 
	     (int2bv 2)) 
	[int2bv 0,int2bv 0]
    ):
    (check_fail (divel [1,1] 0) []):
    []
;

check_res test_divel;

//testcases for lmax
(printf "test_lmax\n");
let test_lmax = 
    (check_eq (lmax [1,-1,2,-2,3,-3]) 3):
    (check_eq (lmax [1.0,-1.0,2.0,-2.0]) 2.0):
    (check_eq
	(lmax [(int2bv 1),(int2bv (-1)),
	      (int2bv 2),(int2bv (-2))])
	(int2bv 2)
    ):
    []
;

check_res test_lmax;

//testcases for lmin
(printf "test_lmin\n");
let test_lmin = 
    (check_eq (lmin [1,-1,2,-2,3,-3]) (-3)):
    (check_eq (lmin [1.0,-1.0,2.0,-2.0]) (-2.0)):
    (check_eq
	(lmin [(int2bv 1),(int2bv (-1)),
	      (int2bv 2),(int2bv (-2))])
	(int2bv (-2))
    ):
    []
;

check_res test_lmin;

//testcases for fstindexof
(printf "test_fstindexof\n");
let test_fstindexof = 
    (check_eq (fstindexof [] 4) 0):
    (check_eq (fstindexof [1,-1,2,-2,3,-3] 4) 0):
    (check_eq (fstindexof [1,-1,2,-2,3,-3] 2) 3):
    []
;

check_res test_fstindexof;

//testcases for argmax
(printf "test_argmax\n");
let test_argmax = 
    (check_eq (argmax {[]::int list}) 0):
    (check_eq (argmax [1,-1,2,-2,3,-3]) 5):
    (check_eq (argmax [1,1,1,1,1,1]) 1):
    []
;

check_res test_argmax;
