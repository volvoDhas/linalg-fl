//tests for ../lib/matrixlist.fl

load (DIR^"../lib/matrixlist.fl");
load (DIR^"flunit.fl");

//NOTE on unit testing strategy
//The main purpose of this library (ref README) is
//to perform linear numerics on floats, ints, bit vectors
//and ranges of these types.
//However, because of a current weakness in 
//the fl framework's type-checking system,
//type inference between the 3 concerned types does
//not always succeed. (Refer to various NOTEs in ../lib/*.fl
//So the primary formula for testing is to ensure
//that types are indeed correctly inferred.
//The next object of importance is of course
//the correctness of the numerical computation.
//The choice of using a heuristic oracle (refer NOTE in ./flunit.fl)
//suffices for the limited ambition of this library
//as a research aid



//NOTE on the general pattern on test cases
//Reflecting the primary strategy on checking
//type inference, each function is tested with
//int, float & bv operands in range and scalar 
//combinations.
//In rare cases, symbolic inputs are tested
//Soundness of numerical computation is an
//important, but secondary concern.
//So test inputs toward this end are only
//at a level to check sanity


//some handy definitions
let lei	    = {[]::int list};
let mei	    = replicate 4 lei;
let li1	    = [1,1];
let lf1	    = map int2float li1;
let lbv1    = map int2bv li1;
let lip	    = [1,2];
let lfp	    = map int2float lip;
let lbvp    = map int2bv lip;
let lzi	    = {zeros 2 :: int list};
let lzf	    = {zeros 2 :: float list};
let lzbv    = {zeros 2 :: bv list};
let mzi	    = {zeros 4 2 :: (int list) list};
let lip	    = [1,2];
let mip	    = replicate 4 lip;
let mzf	    = {zeros 4 2 :: (float list) list};
let lfp	    = [1.0,2.0];
let mfp	    = replicate 4 lfp;
let mzbv    = {zeros 4 2 :: (bv list) list};
let lbvp    = [int2bv 1, int2bv 2];
let mbvp    = replicate 4 lbvp;
let mi1	    = replicate 4 li1;
let mf1	    = mmap int2float mi1;
let mbv1    = mmap int2bv mi1;
let scale   = '256;
let miid    = [[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]];
let mfid    = mmap int2float miid;
let mbvid   = mmap int2bv miid;
let lir2    = [mk_range (-2) (-1), mk_range 1 2];
let lir1    = [mk_range (-1) 0, mk_range 0 1];
let lfr2    = map intr2floatr lir2;
let lfr1    = map intr2floatr lir1;
let lbvr2   = map intr2bvr  lir2;
let lbvr1   = map intr2bvr  lir1;
let mir2    = replicate 4 lir2;
let mfr2    = replicate 4 lfr2;
let mbvr2   = replicate 4 lbvr2;
let irlt1   = mk_range (-1) 1;
let frlt1   = intr2floatr irlt1;
let bvrlt1  = intr2bvr irlt1;

//testcases for mk_range
let test_mk_range =
(printf "test_mk_range\n") seq
    val (RANGE xi yi) =  (mk_range 1 4) in
    val (RANGE xf yf) =  (mk_range 1.0 4.0) in
    val (RANGE xb yb) =  (mk_range (int2bv 1) (int2bv 4)) in
    val (RANGE xbe ybe) =  (mk_range (int2bev 1) (int2bev 4)) in
    let ls = variable "l" => (int2bv 1) | (int2bv 2) in
    let hs = variable "h" => (int2bv 2) | (int2bv 3) in
    let ls' = variable "l" => (int2bv 4) | (int2bv 5) in
    val (RANGE xs ys) = mk_range ls hs in
    (check_eq (xi,yi) (1,4)):
    (check_eq (xf,yf) (1.0,4.0)):
    (check_eq (xb,yb) (int2bv 1,int2bv 4)):
    (check_eq (xbe,ybe) (int2bev 1,int2bev 4)):
    (check_eq (xs,ys) (ls,hs)):
    (check_fail (mk_range ls' hs) (RANGE (int2bv 0) (int2bv 0))):
    []
;

check_res test_mk_range;

//testcases for intr2floatr
let test_intr2floatr =
(printf "test_intr2floatr\n") seq
    val (RANGE xf yf) = intr2floatr (mk_range 1 2) in
    (check_eq (xf,yf) (1.0,2.0)):
    []
;

check_res test_intr2floatr;

//testcases for intr2bvr
let test_intr2bvr =
(printf "test_intr2bvr\n") seq
    val (RANGE xf yf) = intr2bvr (mk_range 1 2) in
    (check_eq (xf,yf) (int2bv 1,int2bv 2)):
    []
;

check_res test_intr2bvr;

//testcases for zipwithsc
let test_zipwithsc = 
(printf "test_zipwithsc\n") seq
    (check_eq (zipwithsc li1 1 (defix +)) (zipwithsc li1 2 (defix *))):
    []
;

check_res test_zipwithsc;

//testcases for zipwith
let test_zipwith = 
(printf "test_zipwith\n") seq
    (check_eq (zipwith li1 li1 (defix +)) (zipwith li1 [2,2] (defix *))):
    []
;

check_res test_zipwith;

//testcases for islempty
let test_islempty = 
(printf "test_islempty\n") seq
    let l = replicate 4 1 in
    (check_false (islempty l)):
    (check_true (islempty lei)):
    []
;

check_res test_islempty;

//testcases for islempty
let test_ismempty = 
(printf "test_ismempty\n") seq
    let l = replicate 4 1 in
    let m = replicate 4 l in
    (check_false (ismempty m)):
    (check_true (ismempty mei)):
    []
;

check_res test_ismempty;


//testcases for zeros
let test_zeros =
(printf "test_zeros\n") seq
    let e1 = {zeros 0 :: int list} in
    let e2 = {zeros (-10) :: int list} in
    let z1 = {zeros 10 :: int list} in
    let me1 = {zeros 0 0 :: (int list) list} in
    let me2 = {zeros 10 (-10) :: (int list) list} in
    let mz1 = {zeros 10 10 :: (int list) list} in
    (check_lempty e1):
    (check_fail e2 []):
    (check_len z1 10):
    (check_mempty me1):
    (check_len mz1 10):
    (check_len (el 1 mz1) 10):
    (check_fail me2 []):
    []
;

check_res test_zeros;

//testcases for mmap
let test_mmap =
(printf "test_mmap\n") seq
    let m = zeros 2 2 in
    let mm = mmap (\e. e+1) m in
    let fmm = filter (\e. e!=1) (flat mm) in 
    (check_len fmm 0):
    []
;

check_res test_mmap;

//testcases for mmap2
let test_mmap2 = 
(printf "test_mmap2\n") seq
    let mm2 = mmap2 opsub mi1 mi1 in
    let fmm2 = filter (\e. e!=0) (flat mm2) in
    (check_len fmm2 0):
    []
;
check_res test_mmap2;

//testcases for lsum
let test_lsum = 
(printf "test_lsum\n") seq
    let li = [1,-1,2,-2,3,-3] in
    let lf = [1.0,-1.0,2.0,-2.0] in
    let lbv =  map int2bv li in
    (check_eq (lsum lei) 0):
    (check_eq (lsum li) 0):
    (check_eq (lsum lf) 0.0):
    (check_eq (lsum lbv) (int2bv 0)):
    (check_eq (lsum lir2) irlt1):
    (check_eq (lsum lfr2) frlt1):
    (check_eq (lsum lbvr2) bvrlt1):
    []
;

check_res test_lsum;

//testcases for msum
let test_msum = 
(printf "test_msum\n") seq
    let li = [1,-1,2,-2,3,-3] in
    let mi = replicate 4 li in
    let lf = [1.0,-1.0,2.0,-2.0] in
    let mf = replicate 4 lf in
    let lbv =  map int2bv li in
    let mbv = replicate 4 lbv in
    let lzi = {zeros 4 :: int list} in
    let lzf = {zeros 4 :: float list} in
    let lzbv = map int2bv lzi in
    (check_eq (msum mei) lzi):
    (check_eq (msum mi) lzi):
    (check_eq (msum mf) lzf):
    (check_eq (msum mbv) lzbv):
    (check_eq (msum mir2) (replicate 4 irlt1)):
    (check_eq (msum mfr2) (replicate 4 frlt1)):
    (check_eq (msum mbvr2) (replicate 4 bvrlt1)):
    []
;

check_res test_msum;


//testcases for laddl
let test_laddl =
(printf "test_laddl\n") seq
    let lin =	[-1,-2] in
    let lfn =	[-1.0,-2.0] in
    let lbvn =  [int2bv (-1),int2bv (-2)] in
    (check_lempty (laddl lei lei)):
    (check_eq (laddl lip lin) lzi):
    (check_eq (laddl lfp lfn) lzf):
    (check_eq (laddl lbvp lbvn) lzbv):
    (check_fail (laddl lip [-1]) []):
    (check_eq (laddl lir2 [1,-1]) lir1):
    (check_eq (laddl lfr2 [1.0,-1.0]) lfr1):
    (check_eq (laddl lbvr2 [int2bv 1,int2bv (-1)]) lbvr1):
    []
;

check_res test_laddl;


//testcases for maddl
let test_maddl =
(printf "test_maddl\n") seq
    let lin =	[-1,-2] in
    let lfn =	[-1.0,-2.0] in
    let lbvn =  [int2bv (-1),int2bv (-2)] in
    (check_mempty (maddl mei lei)):
    (check_eq (maddl mip lin) mzi):
    (check_eq (maddl mfp lfn) mzf):
    (check_eq (maddl mbvp lbvn) mzbv):
    (check_eq (maddl mir2 [0,0]) mir2):
    []
;

check_res test_maddl;


//test_cases for maddm
let test_maddm = 
(printf "test_maddm\n") seq
    let r = maddm mi1 mi1 in
    let fr = filter (\e. e!= 2) (flat r) in
    (check_len fr 0):
    []
;

check_res test_maddm;

//testcases for laddsc
let test_laddsc = 
(printf "test_laddsc\n") seq
    let li1 = [1,1] in
    let lf1 = [1.0,1.0] in
    let lbv1 = map int2bv li1 in
    let lzi = {zeros 2 :: int list} in
    let lzf = {zeros 2 :: float list} in
    let lzbv = {zeros 2 :: bv list} in
    (check_lempty (laddsc lei 1)):
    (check_eq (laddsc li1 (-1)) lzi):
    (check_eq (laddsc lf1 (-1.0)) lzf):
    (check_eq (laddsc lbv1  (int2bv (-1))) lzbv):
    (check_eq (laddsc lir1 0) lir1):
    (check_eq (laddsc lfr1 0.0) lfr1):
    (check_eq (laddsc lbvr1 (int2bv 0)) lbvr1):
    []
;

check_res test_laddsc;

//testcases for maddsc
let test_maddsc = 
(printf "test_maddsc\n") seq
    let m1i = replicate 2 [1,1] in
    let m1f = replicate 2 [1.0,1.0] in
    let m1bv = mmap int2bv m1i in
    let mzi = {zeros 2 2 :: (int list) list} in
    let mzf = {zeros 2 2 :: (float list) list} in
    let mzbv = {zeros 2 2 :: (bv list) list} in
    (check_mempty (maddsc mei 1)):
    (check_eq (maddsc m1i (-1)) mzi):
    (check_eq (maddsc m1f (-1.0)) mzf):
    (check_eq (maddsc m1bv  (int2bv (-1))) mzbv):
    (check_eq (maddsc mir2 0) mir2):
    []
;

check_res test_maddsc;

let lir22 = [mk_range (-2) 0, mk_range 0 2];
let mir22 = replicate 4 lir22;
let lfr22 = map intr2floatr lir22;
let lbvr22 = map intr2bvr lir22;

//testcases for ldiffl
let test_ldiffl = 
(printf "test_ldiffl\n") seq
    (check_lempty (ldiffl lei lei)):
    (check_eq (ldiffl lip lip) lzi):
    (check_eq (ldiffl lfp lfp) lzf):
    (check_eq (ldiffl lbvp lbvp) lzbv):
    (check_fail (ldiffl lip [-1]) []):
    (check_eq (ldiffl lir2 lir1) lir22):
    (check_eq (ldiffl lfr2 lfr1) lfr22):
    (check_eq (ldiffl lbvr2 lbvr1) lbvr22):
    []
;

check_res test_ldiffl;

//testcases for mdiffl
let test_mdiffl = 
(printf "test_mdiffl\n") seq
    (check_mempty (mdiffl mei lei)):
    (check_eq (mdiffl mip lip) mzi):
    (check_eq (mdiffl mfp lfp) mzf):
    (check_eq (mdiffl mbvp lbvp) mzbv):
    (check_fail (mdiffl mip [-1]) [[]]):
    (check_eq (mdiffl mir2 lir1) mir22):
    []
;

check_res test_mdiffl;

//test_cases for mdiffm:
let test_mdiffm = 
(printf "test_mdiffm\n") seq
    let r = mdiffm mi1 mi1 in
    (check_eq r mzi):
    []
;

check_res test_mdiffm;

let lir3 = [mk_range (-3) 0, mk_range 0 3];
let mir3 = replicate 4 lir3;
let lfr3 = map intr2floatr lir3;
let lbvr3 = map intr2bvr lir3;

//testcases for ldiffsc
let test_ldiffsc = 
(printf "test_ldiffsc\n") seq
    (check_lempty (ldiffsc lei 1)):
    (check_eq (ldiffsc li1 1) lzi):
    (check_eq (ldiffsc lf1 1.0) lzf):
    (check_eq (ldiffsc lbv1 (int2bv 1)) lzbv):
    (check_eq (ldiffsc lir2 irlt1) lir3):
    (check_eq (ldiffsc lfr2 frlt1) lfr3):
    (check_eq (ldiffsc lbvr2 bvrlt1) lbvr3):
    []
;

check_res test_ldiffsc;

//testcases for mdiffsc
let test_mdiffsc = 
(printf "test_mdiffsc\n") seq
    (check_mempty (mdiffsc mei 1)):
    (check_eq (mdiffsc mi1 1) mzi):
    (check_eq (mdiffsc mf1 1.0) mzf):
    (check_eq (mdiffsc mbv1 (int2bv 1)) mzbv):
    (check_eq (mdiffsc mir2 irlt1) mir3):
    []
;

check_res test_mdiffsc;


//testcases for dot
let test_dot =
(print "test_dot\n") seq
    let xi = [1,0,0,1] in
    let yi = [4,1,2,2] in
    let yi' = [4,1,2] in
    let xf = map int2float xi in
    let yf = map int2float yi in
    let xb = map int2bv xi in
    let yb = map int2bv yi in 
    (check_eq (dot xi yi) 6):
    (check_eq (dot xf yf) (int2float 6)):
    (check_eq (dot xb yb) (int2bv 6)):
    (check_fail (dot xi yi') (-255)):
    (check_eq (dot lir2 [-1,-1]) irlt1):
    (check_eq (dot lfr2 [-1.0,-1.0]) frlt1):
    (check_eq (dot lbvr2 [int2bv (-1),int2bv (-1)]) bvrlt1):
    []
;

check_res test_dot;


//testcases for mmulm
let test_mmulm =
(print "test_mmulm\n") seq
    let yi = replicate 4 [4,1,2,2] in
    let yi' = replicate 3 [4,1,2] in
    let yf = mmap int2float yi in
    let yb = mmap int2bv yi in 
    (check_eq (mmulm miid yi) yi):
    (check_eq (mmulm mfid yf) yf):
    (check_eq (mmulm mbvid yb) yb):
    (check_fail (mmulm miid yi') [[]]):
    (check_eq 
	(mmulm mir2 (replicate 2 [1,1])) 
	(replicate 4 (replicate 2 irlt1))
    ):
    []
;

check_res test_mmulm;

//testcases for mmultm
let test_mmultm =
(print "test_mmultm\n") seq
    let yi = transpose (replicate 4 [4,1,2,2]) in
    let yi' = transpose (replicate 3 [4,1,2]) in
    let yf = transpose (mmap int2float yi) in
    let yb = transpose (mmap int2bv yi) in 
    (check_eq (mmultm miid yi) (transpose yi)):
    (check_eq (mmultm mfid yf) (transpose yf)):
    (check_eq (mmultm mbvid yb) (transpose yb)):
    (check_fail (mmultm miid yi') [[]]):
    (check_eq 
	(mmultm mir2 (transpose (replicate 2 [1,1,1,1])))
	(replicate 4 (replicate 4 irlt1))
    ):
    []
;

check_res test_mmultm;

//testcases for lmulsc
let test_lmulsc = 
(printf "test_lmulsc\n") seq
    let lir2' = [mk_range 1 2, mk_range (-2) (-1)] in
    (check_lempty (lmulsc lei 1)):
    (check_eq (lmulsc li1 0) lzi):
    (check_eq (lmulsc lf1 0.0) lzf):
    (check_eq (lmulsc lbv1 (int2bv 0)) lzbv):
    (check_eq (lmulsc lir2 (-1)) lir2'):
    (check_eq (lmulsc lfr2 (-1.0)) (map intr2floatr lir2')):
    (check_eq (lmulsc lbvr2 (int2bv (-1))) (map intr2bvr lir2')):
    []
;

check_res test_lmulsc;

////testcases for divel
//(printf "test_divel\n");
//let test_divel = 
//    (check_lempty (divel lei 1)):
//    (check_eq (divel [1,1] 2) [0,0]):
//    (check_eq (divel [1.0,1.0] 2.0) [0.5,0.5]):
//    (check_eq 
//	(divel [int2bv 1, int2bv 1] 
//	     (int2bv 2)) 
//	[int2bv 0,int2bv 0]
//    ):
//    (check_fail (divel [1,1] 0) []):
//    []
//;
//
//check_res test_divel;

//testcases for lmax
let test_lmax = 
(printf "test_lmax\n") seq
    (check_eq (lmax [1,-1,2,-2,3,-3]) 3):
    (check_eq (lmax [1.0,-1.0,2.0,-2.0]) 2.0):
    (check_eq
	(lmax [(int2bv 1),(int2bv (-1)),
	      (int2bv 2),(int2bv (-2))])
	(int2bv 2)
    ):
    []
;

check_res test_lmax;

//testcases for lmin
let test_lmin = 
(printf "test_lmin\n") seq
    (check_eq (lmin [1,-1,2,-2,3,-3]) (-3)):
    (check_eq (lmin [1.0,-1.0,2.0,-2.0]) (-2.0)):
    (check_eq
	(lmin [(int2bv 1),(int2bv (-1)),
	      (int2bv 2),(int2bv (-2))])
	(int2bv (-2))
    ):
    []
;

check_res test_lmin;

//testcases for fstindexof
let test_fstindexof = 
(printf "test_fstindexof\n") seq
    (check_eq (fstindexof [] 4) 0):
    (check_eq (fstindexof [1,-1,2,-2,3,-3] 4) 0):
    (check_eq (fstindexof [1,-1,2,-2,3,-3] 2) 3):
    []
;

check_res test_fstindexof;

//testcases for largmax
let test_largmax = 
(printf "test_largmax\n") seq
    (check_eq (largmax lei) 0):
    (check_eq (largmax [1,-1,2,-2,3,-3]) 5):
    (check_eq (largmax [1,1,1,1,1,1]) 1):
    []
;

check_res test_largmax;

//testcases for largnmax
let test_largnmax = 
(printf "test_largnmax\n") seq
    (check_eq (largnmax lei 2) [0]):
    (check_eq (largnmax [1,-1,2,-2,3,-3] 2) [5,3]):
    (check_eq (largnmax [1,1,1,1,1,1] 2) [6,5]):
    []
;

check_res test_largnmax;

//testcases for margmax
let test_margmax = 
(printf "test_margmax\n") seq
    let t1 = replicate 4 [1,-1,2,-2,3,-3] in
    let t2 = replicate 4 [1,1,1,1] in
    (check_eq (margmax mei) (replicate 4 0)):
    (check_eq (margmax t1) (replicate 4 5)):
    (check_eq (margmax t2) (replicate 4 1)):
    []
;

check_res test_margmax;

//testcases for margnmax
let test_margnmax = 
(printf "test_margnmax\n") seq
    let t1 = replicate 4 [1,-1,2,-2,3,-3] in
    let t2 = replicate 4 [1,1,1,1] in
    (check_eq (margnmax t1 2) (replicate 4 [5,3])):
    (check_eq (margnmax t2 2) (replicate 4 [4,3])):
    []
;

check_res test_margnmax;

