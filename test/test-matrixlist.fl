//tests for ../lib/matrixlist.fl

load (DIR^"../lib/matrixlist.fl");

//check if evaluation of f returns T
let check_true f =  f == T;

//check if evaluation of f returns F
let check_false f =  f == F;

//check if evaluation is an empty list
let check_lempty f = islempty f;

//check if evaluation is an empty matrix
let check_mempty f = ismempty f;

//check equivalence between output and expected result
let check_eq a b = a == b;

//check if length of returned list is equal to expected value
let check_len l n = check_eq (length l) n;

//check if executing the function fails
//supply fflag as a sanity check
//fflag should be the same type as the correct output
//and choose a value that cannot be expected even if 
//execution does not fail

let check_fail f fflag = 
    let trycatch f =
	f gen_catch (\e. fflag)
    in
   (trycatch f) == fflag
;

//checks and compiles results of a test case
//rs:: a list of T or F depending upon 
//whether a test pased or failed

let check_res rs =
    let ntcs = (length rs) in
    letrec check_test n =
	n > ntcs => 0 |
	(el n rs) => 1 + (check_test (n+1)) |
	(printf "TC -%3d failed\n" n) seq (check_test (n+1))
    in
    let npass = check_test 1 in
    (printf "Result - %d/%d TCs passed\n\n" npass ntcs) seq ()
;

//some handy definitions
let lei	    = {[]::int list};
let mei	    = replicate 4 lei;
let l1i	    = [1,1];
let l1f	    = map int2float l1i;
let l1bv    = map int2bv l1i;
let lip	    = [1,2];
let lfp	    = map int2float lip;
let lbvp    = map int2bv lip;
let lzi	    = {zeros 2 :: int list};
let lzf	    = {zeros 2 :: float list};
let lzbv    = {zeros 2 :: bv list};
let mzi	    = {zeros 4 2 :: (int list) list};
let lip	    = [1,2];
let mip	    = replicate 4 lip;
let mzf	    = {zeros 4 2 :: (float list) list};
let lfp	    = [1.0,2.0];
let mfp	    = replicate 4 lfp;
let mzbv    = {zeros 4 2 :: (bv list) list};
let lbvp    = [int2bv 1, int2bv 2];
let mbvp    = replicate 4 lbvp;
let mi1	    = replicate 4 l1i;
let mf1	    = mmap int2float mi1;
let mbv1    = mmap int2bv mi1;

//testcases for islempty
(printf "test_islempty\n");
let test_islempty = 
    let l = replicate 4 1 in
    (check_false (islempty l)):
    (check_true (islempty lei)):
    []
;

check_res test_islempty;

//testcases for islempty
(printf "test_ismempty\n");
let test_ismempty = 
    let l = replicate 4 1 in
    let m = replicate 4 l in
    (check_false (ismempty m)):
    (check_true (ismempty mei)):
    []
;

check_res test_ismempty;


//testcases for zeros
(printf "test_zeros\n");
let test_zeros =
    let e1 = {zeros 0 :: int list} in
    let e2 = {zeros (-10) :: int list} in
    let z1 = {zeros 10 :: int list} in
    let me1 = {zeros 0 0 :: (int list) list} in
    let me2 = {zeros 10 (-10) :: (int list) list} in
    let mz1 = {zeros 10 10 :: (int list) list} in
    (check_lempty e1):
    (check_fail e2 []):
    (check_len z1 10):
    (check_mempty me1):
    (check_len mz1 10):
    (check_len (el 1 mz1) 10):
    (check_fail me2 []):
    []
;

check_res test_zeros;

//testcases for mmap
(printf "test_mmap\n");
let test_mmap =
    let m = zeros 2 2 in
    let mm = mmap (\e. e+1) m in
    let fmm = filter (\e. e!=1) (flat mm) in 
    (check_len fmm 0):
    []
;

check_res test_mmap;

//testcases for lsum
(printf "test_lsum\n");
let test_lsum = 
    let li = [1,-1,2,-2,3,-3] in
    let lf = [1.0,-1.0,2.0,-2.0] in
    let lbv =  map int2bv li in
    (check_eq (lsum lei) 0):
    (check_eq (lsum li) 0):
    (check_eq (lsum lf) 0.0):
    (check_eq (lsum lbv) (int2bv 0)):
    []
;

check_res test_lsum;

//testcases for msum
(printf "test_msum\n");
let test_msum = 
    let li = [1,-1,2,-2,3,-3] in
    let mi = replicate 4 li in
    let lf = [1.0,-1.0,2.0,-2.0] in
    let mf = replicate 4 lf in
    let lbv =  map int2bv li in
    let mbv = replicate 4 lbv in
    let lzi = {zeros 4 :: int list} in
    let lzf = {zeros 4 :: float list} in
    let lzbv = map int2bv lzi in
    (check_eq (msum mei) lzi):
    (check_eq (msum mi) lzi):
    (check_eq (msum mf) lzf):
    (check_eq (msum mbv) lzbv):
    []
;

check_res test_msum;


//testcases for laddl
(printf "test_laddl\n");
let test_laddl =
    let lin =	[-1,-2] in
    let lfn =	[-1.0,-2.0] in
    let lbvn =  [int2bv (-1),int2bv (-2)] in
    (check_lempty (laddl lei lei)):
    (check_eq (laddl lip lin) lzi):
    (check_eq (laddl lfp lfn) lzf):
    (check_eq (laddl lbvp lbvn) lzbv):
    (check_fail (laddl lip [-1]) []):
    []
;

check_res test_laddl;


//testcases for maddl
(printf "test_maddl\n");
let test_maddl =
    let lin =	[-1,-2] in
    let lfn =	[-1.0,-2.0] in
    let lbvn =  [int2bv (-1),int2bv (-2)] in
    (check_mempty (maddl mei lei)):
    (check_eq (maddl mip lin) mzi):
    (check_eq (maddl mfp lfn) mzf):
    (check_eq (maddl mbvp lbvn) mzbv):
    []
;

check_res test_maddl;


//testcases for laddsc
(printf "test_laddsc\n");
let test_laddsc = 
    let l1i = [1,1] in
    let l1f = [1.0,1.0] in
    let l1bv = map int2bv l1i in
    let lzi = {zeros 2 :: int list} in
    let lzf = {zeros 2 :: float list} in
    let lzbv = {zeros 2 :: bv list} in
    (check_lempty (laddsc lei 1)):
    (check_eq (laddsc l1i (-1)) lzi):
    (check_eq (laddsc l1f (-1.0)) lzf):
    (check_eq (laddsc l1bv  (int2bv (-1))) lzbv
    ):
    []
;

check_res test_laddsc;

//testcases for maddsc
(printf "test_maddsc\n");
let test_maddsc = 
    let m1i = replicate 2 [1,1] in
    let m1f = replicate 2 [1.0,1.0] in
    let m1bv = mmap int2bv m1i in
    let mzi = {zeros 2 2 :: (int list) list} in
    let mzf = {zeros 2 2 :: (float list) list} in
    let mzbv = {zeros 2 2 :: (bv list) list} in
    (check_mempty (maddsc mei 1)):
    (check_eq (maddsc m1i (-1)) mzi):
    (check_eq (maddsc m1f (-1.0)) mzf):
    (check_eq (maddsc m1bv  (int2bv (-1))) mzbv):
    []
;

check_res test_maddsc;

//testcases for ldiffl
(printf "test_ldiffl\n");
let test_ldiffl = 
    (check_lempty (ldiffl lei lei)):
    (check_eq (ldiffl lip lip) lzi):
    (check_eq (ldiffl lfp lfp) lzf):
    (check_eq (ldiffl lbvp lbvp) lzbv):
    (check_fail (ldiffl lip [-1]) []):
    []
;

check_res test_ldiffl;

//testcases for mdiffl
(printf "test_mdiffl\n");
let test_mdiffl = 
    (check_mempty (mdiffl mei lei)):
    (check_eq (mdiffl mip lip) mzi):
    (check_eq (mdiffl mfp lfp) mzf):
    (check_eq (mdiffl mbvp lbvp) mzbv):
    (check_fail (mdiffl mip [-1]) [[]]):
    []
;

check_res test_mdiffl;


//testcases for ldiffsc
(printf "test_ldiffsc\n");
let test_ldiffsc = 
    (check_lempty (ldiffsc lei 1)):
    (check_eq (ldiffsc l1i 1) lzi):
    (check_eq (ldiffsc l1f 1.0) lzf):
    (check_eq (ldiffsc l1bv (int2bv 1)) lzbv):
    []
;

check_res test_ldiffsc;

//testcases for mdiffsc
(printf "test_mdiffsc\n");
let test_mdiffsc = 
    (check_mempty (mdiffsc mei 1)):
    (check_eq (mdiffsc mi1 1) mzi):
    (check_eq (mdiffsc mf1 1.0) mzf):
    (check_eq (mdiffsc mbv1 (int2bv 1)) mzbv):
    []
;

check_res test_ldiffsc;


//testcases for dot
(print "test_dot\n");
let test_dot =
    let xi = [1,0,0,1] in
    let yi = [4,1,2,2] in
    let yi' = [4,1,2] in
    let xf = map int2float xi in
    let yf = map int2float yi in
    let xb = map int2bv xi in
    let yb = map int2bv yi in 
    (check_eq (dot xi yi) 6):
    (check_eq (dot xf yf) (int2float 6)):
    (check_eq (dot xb yb) (int2bv 6)):
    (check_fail (dot xi yi') (-255)):
    []
;

check_res test_dot;

let miid = [[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]];
let mfid = mmap int2float miid;
let mbvid = mmap int2bv miid;

//testcases for mmulm
(print "test_mmulm\n");
let test_mmulm =
    let yi = replicate 4 [4,1,2,2] in
    let yi' = replicate 3 [4,1,2] in
    let yf = mmap int2float yi in
    let yb = mmap int2bv yi in 
    (check_eq (mmulm miid yi) yi):
    (check_eq (mmulm mfid yf) yf):
    (check_eq (mmulm mbvid yb) yb):
    (check_fail (mmulm miid yi') [[]]):
    []
;

check_res test_mmulm;

//testcases for mmultm
(print "test_mmultm\n");
let test_mmultm =
    let yi = transpose (replicate 4 [4,1,2,2]) in
    let yi' = transpose (replicate 3 [4,1,2]) in
    let yf = transpose (mmap int2float yi) in
    let yb = transpose (mmap int2bv yi) in 
    (check_eq (mmultm miid yi) (transpose yi)):
    (check_eq (mmultm mfid yf) (transpose yf)):
    (check_eq (mmultm mbvid yb) (transpose yb)):
    (check_fail (mmultm miid yi') [[]]):
    []
;

check_res test_mmultm;

//testcases for lmulsc
(printf "test_lmulsc\n");
let test_lmulsc = 
    (check_lempty (lmulsc lei 1)):
    (check_eq (lmulsc l1i 0) lzi):
    (check_eq (lmulsc l1f 0.0) lzf):
    (check_eq (lmulsc l1bv (int2bv 0)) lzbv):
    []
;

check_res test_lmulsc;

//testcases for divel
(printf "test_divel\n");
let test_divel = 
    (check_lempty (divel lei 1)):
    (check_eq (divel [1,1] 2) [0,0]):
    (check_eq (divel [1.0,1.0] 2.0) [0.5,0.5]):
    (check_eq 
	(divel [int2bv 1, int2bv 1] 
	     (int2bv 2)) 
	[int2bv 0,int2bv 0]
    ):
    (check_fail (divel [1,1] 0) []):
    []
;

check_res test_divel;

//testcases for lmax
(printf "test_lmax\n");
let test_lmax = 
    (check_eq (lmax [1,-1,2,-2,3,-3]) 3):
    (check_eq (lmax [1.0,-1.0,2.0,-2.0]) 2.0):
    (check_eq
	(lmax [(int2bv 1),(int2bv (-1)),
	      (int2bv 2),(int2bv (-2))])
	(int2bv 2)
    ):
    []
;

check_res test_lmax;

//testcases for lmin
(printf "test_lmin\n");
let test_lmin = 
    (check_eq (lmin [1,-1,2,-2,3,-3]) (-3)):
    (check_eq (lmin [1.0,-1.0,2.0,-2.0]) (-2.0)):
    (check_eq
	(lmin [(int2bv 1),(int2bv (-1)),
	      (int2bv 2),(int2bv (-2))])
	(int2bv (-2))
    ):
    []
;

check_res test_lmin;

//testcases for fstindexof
(printf "test_fstindexof\n");
let test_fstindexof = 
    (check_eq (fstindexof [] 4) 0):
    (check_eq (fstindexof [1,-1,2,-2,3,-3] 4) 0):
    (check_eq (fstindexof [1,-1,2,-2,3,-3] 2) 3):
    []
;

check_res test_fstindexof;

//testcases for largmax
(printf "test_largmax\n");
let test_largmax = 
    (check_eq (largmax lei) 0):
    (check_eq (largmax [1,-1,2,-2,3,-3]) 5):
    (check_eq (largmax [1,1,1,1,1,1]) 1):
    []
;

check_res test_largmax;

//testcases for margmax
(printf "test_margmax\n");
let test_margmax = 
    let t1 = replicate 4 [1,-1,2,-2,3,-3] in
    let t2 = replicate 4 [1,1,1,1] in
    (check_eq (margmax mei) lzi):
    (check_eq (margmax t1) (replicate 4 5)):
    (check_eq (margmax t2) (replicate 4 1)):
    []
;

check_res test_largmax;
